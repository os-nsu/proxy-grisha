Кеш и собственный аллокатор
==================================
Этот каталог содержит реализацию кеша фиксированного размера для которого исользуется собственный аллокатор.
Для работы с кешем напрямую используются методы, описанные в файле cache.c. Для работы
через сеть методы из cache_network.c. В качестве алогоритма кеширования выбран модернизированный
варант LRU учитывающий наличие у пакетов времени валидности.

Как работает кеш?
==================================
Кеш описывают две структуры: ассоциативный массив, использующийся для быстрого доступа к данным,
и очередь с приоритетом необходимая для работы LRU. В качестве метода разрешения коллизий используется метод
цепочек, а в качестве хеш функции простенький полиномиальный хеш. Для обеспечения быстрой работы  алгоритма LRU
эти струтуры жестко связаны: очередь содержит ссылку на соответсвующий элемент ассоциативного массива, а ассоциативный
массив содержит индекс сооветсвующего элемента из очереди (пока не готово, но планирую добавить). Благодаря этому
при работе алгоритма LRU нет необходимости искать элемент из ассоциативного массива, соответсвующий элементу очереди.
Работа с кешем происходит через методы cache_read и cache_write из файла cache.c (а также методами из файла cache_network.c,
которые будут реализованы позже). Эти методы инкапсулирут всё взаимодействие со стркутурами и объединяют их.

В целом алгоритм очистки кеша можно описать так:
1. Использовать стандартный алгоритм LRU при переполнениии кеша (для его реализции используется
очередь с приоритетом на основе минимальной кучи из фалйа LRU_queue.c).

2. При попытке получения данных из кеша смотрим не истёк ли их срок валидности. Если истёк,
то удаляем их из всех структур (ленивая очистка).

2.1 Если для получения данных используется функция-обёртка для работы с сетью, то автоматически
посылаем на сервер запрос на получение новых данных, кешируем их и перенаправляем пользователю.

2.2 Если для получения данных используется стадартная функция для работы с кешем, то говорим пользователю
что информация в кеше устарела и просим обновить её.

2.3 Обновляем информацию о последнем времени запроса в очереди для LRU.

* Все времена сохраняются в милисекундах

Как работает аллокатор?
=================================
Аллокатор может выделять память произвольного размера. Для её отделения от остальной части памяти используются заголовки,
содержащие разсмер выделенной памяти, ссылки на предыдущий и следующий заголовки, информацию на то, свободен ли блок,
является ли его содержимое указателем на файловый поток (задел на будущее), а также индекс этого блока в куче (максимальной).

Куча выделяется вместе с основным блоком памяти и находится сразу перед ним. Она содержит информацию
только о свободных блоках и нужна для быстрого их поиска (в частности для
быстрой проверки можем ли мы выделить блок нужного размера. Это важно полскольку LRU в моей реализации
будет пытаться вытеснять устаревшие сообщения пока не сможет вставить новое, что может быть не быстро, а значит проверка на возможность вставки не должна быть узким местом). Подробнее о вычеслении размера кучи можно почитать в документации к функциям.

Указатели на следующий и предыдущий блоки нужны для борьбы с фрагментацией аллоцированной памяти.
При освобождении блока проверяется свободны ли его соседи. Сначала проверяется сосед справа (по указателю next),
если он свободен, то правый блок удаляется из кучи свобдных блков иприсединятеся к текущему.
Далее провреяем соседа слева (по указателю previous) и, если он свободен, то теперь присоединяем текущий блок к левому
и перебалансируем кучу чтобы сохранить её свойства. Если же левый блок не свободен, то добавялем получившийся до этого
блок в кучу (таким образом оказавшиеся рядом 2 или 3 блока скелятся, а больше их рядом оказаться и не может в силу того,
что блок становится свободным только при операции free). Стоит отметить, что скелить можно только находящиеся в физическом
смысле рядом блоки (то есть например блоки из "начала" и конца выделенной памяти не склеятся (то есть плучившийся двусвязный
список из блоков не является циклическим)).

ВАЖНО: Аллокатор никак не проверяет валидность адреса. Передача неправильного адреса в функцию - неопределённое поведение.