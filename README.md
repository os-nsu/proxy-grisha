oos-proxy
========================================
Прокси сервер для курса ООС ФИТ НГУ

Сборка
========================================
 - Заходим в корневую дирректорию программы
 - Для сборки обычной версии запускаем make
 - Для сборки отладочной версии запускаем make debug
 - В обоих случаях в корневой дирректории проекта создаётся каталог install
в котором хранятся все библиотеки и исполняемый файл проекта
 - Все объектные файлы сохраняются в корневой дирректории проекта

Очистка
========================================
 - Для удаления дирректории install используйте команду make clean_source_dir
 - Для удаления всех объектных файлов используйте команду make clean_obj
 - Для полного удаления всех артефактов сборки используйте make clean

Задание 1 (Compile & assembling & launch)
========================================
Создать прорамму, умеющую подгружать разделяемые библиотки
и инициальзировать их. В качестве первой разделяемой библиотеки можно
использовать несколько hello-world like методов и один публичный init
(протокол взаимодествия придумать самостоятельно), собранных в один .so файл.
Сборка программы и библиотки осуществляется с помощью make-файлов. Дирректорию,
в которой нахдятся библиотеки пока можно захардкодить, а в дальнейшем вынести в
конфиг.
Для того, чтобы расширение могло запрашивать выполнение различных операций (например
внесения данных в кеш, чтение их оттуда, регистрация нового процесса для себя и т.д.)
создать в отдельном файле струтуру операций (она должна содержать имя операции и указатель
(void *) на аргументы для неё (их также можно ввиде струтуры оформить)), функции их выполняющие
(можно пока просто объявить безреализации или добавлять их по мере необходимости) и стек, содержащий эти струтуры.
Для того, чтобы вызывать эти функции из разделяемой библиотеки создать структуру, содержащую
указатели на них, и передовать её в качетсве первого аргумента для init.

* Добавить возможность выбора времени вызова этих операций в процессе boss (после полной инициализации,
после минимально необходимой инициализации, перед завершением, прямо сейчас). Для этого можно использовать
уже готовые струтуры операций и стека.

Примечание: не для всех операций можно задать время их выполнения. Допустим создание нового
процесса для операции как мне кажется лучше выполнить после выхода из функции init. Для этого
как раз и нужны структура, описывающая операцию, и стек из них. 

Задание 2 (Files)
========================================
Написать логгер и парсер конфиг файла. Можно как расширения или
как часть функционала. Суть в том, чтобы потом можно было обсудить, что происходит
при создании, открытии и удалении файлов.
Для логгера создать несколько уровней сообщений
об ошибках. Строка, выводимая логгером в файл, должна содержать время создания лога, дату его создания,
часовой пояс, уровень сообщения об ошибке, само сообщение (можно сделать форматную строку как в printf).
Это необходимый мимнимум, можно и больше информации добавить (например имя файла и строку из которой
была вызвана функция логгирования).
Парсер конфига должен корректно обрабатывать комментарии и работать с переменными двух типов
(тип не указывается как в си, а должен определяться во время парсинга): long и string. Переменные
из конфига можно записывать в глобальные переменные чтобы с ними было проще работать.

* Ограничить размер лог файла и сделать его циклическим (можно просто менять два лог файла между собой)
* Расширить систему типов парсера добавив в него bool и double
* Вместо использования глобальных переменных для хранения значений из конфига сделать свой GUC

Задание 3 (Address space)
=========================================
Написать собственный аллокатор (можно выбрать любой, но я бы взял похожий на malloc). Аллокатор
должен уметь выделять память и возвращать указатель на выделенную память, и освобождать память по
этому указателю. При этом он не должен использовать уже готовую кучу, а должен присоединять регион и работать с ним.
Для проверки его работоспособности можно связать его с файлом.
Написать на основе этого аллокатора собственный кеш фиксированного размера (задаётся через конфиг).
Он должен уметь записывать в выделенную аллокатором память переданные данные и доставать и оттуда.
Алгоритм кеширования можно использовать любой. Для проверки работоспособности попробовать закешировать
какие-либо данные (например содержимое файла /proc/self/maps для последующего ответа семинаристу).
Работу с кешем для этого случая вынести в отдельное расширение с помошью дополнительных операций (см пункт 1)
write_to_cache_op и read_from_cache_op;

* Добавить поддержку TTL (Time To Live) чтобы не хранить не валидные данные
* Для быстрого поиска свободного участка памяти добавить в аллокатор какую-либо дополнительную структуру данных
(например кучу)
* Если используется алгоритм кеширования LRU, то дополнительно хранить очередь с приоритетом для ускорения его работы.

Задание 4 (Processes)
=========================================
 1. Написать новое расширение для вычисления синуса с помощью разложения в ряд (или что угодно, что можно запустить
в фоне параллельно основному процессу).
 2. Вынести выполнение этой операции в отдельный процесс с помощью системного вызова clone.
(как это можно сделать описано в протоколе взаимодейсвия основного процесса и расширения
(backend/src/shlib_operations/README.md)).
 3. Дочерние процессы должны не только порождаться, но и корректно завершаться (с освобождением стека и всем прочим),
а значит где-то надо хранить струтуры, их описывающие.

* Добавить в логгер возможность логировать сообщения сразу нескольких процессов (пока без примитивов синхронизации).

Задание 5 (System calls)
=========================================
Расширить процедуру создания дочерних процессов для расширений добавив возможность
создавать дополнитьельный процесс-трассер, который будет одключаться к дочернему
процессу с помощью ptrace и печатать коды системных вызовов нашего дочернего процесса.
Дочерний процесс для расширения должен порождать трассер, поскольку иначе без изменений
в конфигурационных файлах операционной системы это работать не будет. Соответсвенно
он же отвечает за завершение этого дочернего процесса.

ПРИМЕЧАНИЕ: Сейчас есть баг, связанный с освобождением памяти под стек процесса расширения.